# 华为2019软件精英挑战赛 --- 初赛代码 初赛成绩 6800+

## 整体思路

1. 车辆路径选择

    考虑了最短路算法对每一辆车进行路径规划，我们组最开始选择了启发式的 A* 算法作为路径选择算法，同时找了 Dijkstra 的实现作为备选的最短路选择算法。本以为 A* 会比 Dijkstra 效果好，在初赛时试过分别试过相同参数下分别选用 Dijkstra 和 A* 作为路径规划算法，发现二者结果基本一样。初赛时看到这一结果初步的猜测是，我们的 A* 实现可能有 BUG，比赛结束还没来得及好好测试我们的 A* 代码，希望后面有时间把这个坑补上。

    为避免最短路结果使大量车辆拥堵在同一道路，我们对道路添加权值，每有一辆车选择了该道路，就增加该道路的权值；同时，考虑先出发的车辆对后续的车辆的影响应该是随时间衰减的，我们还采用了权值衰减。

    我们对调度算法进行时间切割，即把车辆调度看作由一系列时间片组成，每个时间片直接用最短路算法得出该车辆的最短路径，作为该车辆最终的路径调度结果。

2. 死锁预防

    死锁预防主要受出题方答疑时给的思路的启发，保证每个车道一直有空余车位，就不会发生死锁。所以控制每个时间片的发车数量，使判题器判题时不会发生死锁。

    总的来说，具体的解决死锁的方法就是，对调度算法中单个时间片的发车数量，引入一个可调参数，然后利用判题器来调这个参数，直到输出刚好不死锁。这种方法在初赛练习赛时我们组调参调到 **单地图 700 ** 的成绩的。

    关于死锁预防问题，队友在出赛前一天，想到可以通过对上面提到的参数，改用一个曲线函数的值去逼近，使单个时间片的发车数量动态变化，达到发车数量在最开始最大，然后逐渐衰减，在调度的中后期再逐渐增加。原因是觉得道路的负载能力应该是随着车辆调度时间沿曲线逐渐下降的，所以推测这种发车数动态变化的策略应该比上面提到发车策略好。然而初赛当天该部分调参次数太少，只调到与之前的效果超不多的程度，没有时间调到比较好的结果。最终提交的代码还是采用先前的方法。

3. 总结反思

    这次比赛，我们组两个人，我负责写代码，队友负责建模找算法给公式。我们总的参赛时间只有 10 天，比赛准备的时间太少，留给队友调参的时间太少了。参赛前几天我太过于关注判题器的实现，直到初赛前一天我还在找代码 BUG，这应该是我们这次比赛的一个败笔。希望这次好好吸取经验和教训，明年再战。

## 代码结果说明

代码目录跟官方给的 SDK 目录结构一样，我们的调度算法在 `getSolution` 目录下实现。
